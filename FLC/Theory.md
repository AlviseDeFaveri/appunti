# Theory of Formal Languages: Basic Notions

* *Alphabet*: finite set of elements $\sum$ = {$a_1$,$a_2$,...,$a_k$}
* *String*: ordered sequence of elements of an alphabet
* *Language*: finite <u>or infinte</u> set of strings $L \subseteq \Sigma^*$
  * *Cardinality*: $| L|$ number of strings in the languages
  * $| \varnothing | = 0 $, $|bbc|_b = 2, |bbc|_a = 0$
  * *Empty* Language $\Phi = \varnothing$

Strings
-----------------

* *Length* $ \mid x \mid$
* *Equality* of strings: same lenght, same elements, same order
* *Concatenation*: associative $(x.y).z = x.(y.z)$
* *Empty* String: $|\epsilon| = 0$ ,  $x.\epsilon = \epsilon.x = x$
  * **N.B:** $$ \{ \epsilon \} \ne \Phi$$ perchè $\Phi$ è il linguaggio vuoto $ = \{ \} = \varnothing$
* *Substring*: $x = u.y.v$
  * $u$ = prefix, $y$ = substring, $v$ = suffix
  * If $u, v \ne \epsilon \implies$  *proper* substring 
  * **N.B:** $\epsilon$ is prefix, suffix and substring of any other string, including itself 
* *Mirror*: $ {(x^R)}^R = x$,   ${(x.y)}^R = y^R.x^R$
* *Iteration* (potenza)
  * **N.B:** $x^0 = \epsilon$,  $\epsilon^n = \epsilon$ for any $n$


Languages
-----------------

* **Prefix** of a language: prefix($L$) = $\{ y | x = y.z  \and x \in L \and y,z \ne \epsilon \}$

  * **Prefix-free language**: no string of the language is the prefix of another string in the language
  * Equivalently: prefix$(L) \cap L = \Phi$

* **Mirror** language: $L^R = \{ x | x = y^R \and y \in L \}$

* **Concatenation**: $L_1.L_2 = \{ x.y | x \in L_1, y \in L_2 \}$

  * **N.B** $$ L . \varnothing = \varnothing . L = \varnothing $$
  * **N.B** $$L. \epsilon = \epsilon.L = L$$

* **Power**: $L^m = L^{m-1}.L$

  * $L^0 = \epsilon$
  * **N.B:** $L = \{ a, b \} \implies L^2 = \{a^2, ab, ba b^2\}$ <u>e non</u> $ \{a^2, b^2\}$

* **Set-Theoretic operations**:  union, intersection, complement, inclusion, equality between languages, inquality between languages etc...

  * Universal Language: given an alphabet $\Sigma$, I have $L_{universal} = \Sigma^0 \cup \Sigma^1 \cup \Sigma^2 ...$
  * Complement: $\neg L = L_{universal} - L​$
  * <u>The complement of a finite language is always an infinite language</u>

* **Star operator** (Kleene): union of all powers of a *language* $L^* = L^0 \cup L^1 \cup L^2 ...$

  * Closed for concatenation: $x \in L^* \and y \in L^* \implies (x.y) \in L^*$
  * Idempotent: $(L^*)^* = L^*$, commutes with mirroring $(L^*)^R = (L^R)^*$
  * $\varnothing^* = \{ \epsilon \}$,  $\{ \epsilon \}$

* **Quotient operator**: $L = L' / L'' = \{  y | y.z \in L' \and z \in L'' \}$

---------------------------------

Regular Expressions and Languages
==============

*Basic operations:* star $e^*$, concatenation $e_1.e_2$, union $e_1 \cup  e_2$. *Symbols*: $ \varnothing, ()$

* *Derived operators*: power, cross
* *Additional operators*: $[ \ ]$ opzionalità, $(a..Z)$ interval of an ordered set
* *Extended regular expressions:* also intersection, complement, difference

## Regexp and REG Family

The **Meaning** of a regexp is a <u>Regular</u> language:

> *Example:* signed integers
>
> * Regexp: $e = (+ \ \cup - \ \cup \epsilon)(0...9)(0...9)^*​$
> * Meaning : $L_e = \{+, -, \epsilon \} \{d\}^+$ with $d \in \{ 0...9 \}$

A **Language is Regular** ($REG$) if it's the meaning of (i.e. it is generated by) a Regexp
$$
Regexp \iff REG
$$

All **Finite Languages** ($FIN$) are regular (but not vice versa)
$$
FIN \sub REG \sub LIB
$$


## Derivation

Given a regexp, one can **always derive another regexp** by replacing a subexpression of the regexp with one of the choices. In this case we say that $e$ derives $e'$:
$$
e \Rightarrow e'
$$

* <u>Choice:</u> 
  * $e$ is a choice for $e^*,  e^+, e^n$
  * $\epsilon$ is a choice for $e^*$
  * $a_3$ is a choice for $a_1 \cup a_2 \cup a_3 ...$
* <u>Derivation:</u>
  * $e \Rightarrow e'$ means that, given  $e = \alpha \beta \gamma$ and $e' = \alpha \delta \gamma$, $\delta$ is a *choice* for the subexpression $\beta$
  * $e \ {\Rightarrow}^n e_n$ if $e_n$ is obtained deriving n times $e$
  * $e \ {\Rightarrow}^+ e_n$ derivation obtained in at least 1 step
  * $e \ {\Rightarrow}^* e_n$ derivation obtained in 0 ore more steps

**Generated Language**: If $e$ is a regular expression, the generated language $L(e)$ is the language formed by all the strings that can be derived by the regexp.
$$
L(e) = \{ x \in {\Sigma}^*  | e \ { \Rightarrow}^* x \}
$$
Two regexps are **Equivalent** if they generate the same language. 

The language defined by a derived regexp is contained in the language defined by the deriving regexp 
$$
e \Rightarrow e_1 \ \ \rightarrow \ \ L(e_1) \subseteq L(e)
$$

## Ambiguity

A string (phrase) may be obtained by two derivations, that differ not only in the order of choices, but in a more substantial way.

A regexp $f $ is **AMBIGUOUS** if the corresponding marked regexp $f_{\#}$ generates two marked strings $x$ and $y$ such that, if the indices are removed, the unmarked strings obtained are identical (this condition is sufficient, not necessary)
$$
f = (a \cup b)^* a(a \cup b)^* \\
\Rightarrow aa(a \cup b)^* \Rightarrow aa
\\
or
\\
\Rightarrow (a \cup b)^* aa \Rightarrow aa
$$

> * Marked regexp $f_{\#} = (a_1 \cup b_2)^* a_3(a_4 \cup b_5)^*$
> * $f_{\#}$ can generate $x = a_1a_3$ and $y = a_3a_4$ that project onto the same phrase $aa$, thus the regexp is ambiguous
>

## Closure

PROPERTY: the family $REG$ of the regular languages is **CLOSED** with respect to the following operators:

* *concatenation*, *union* and *star*
* therefore $REG$ is closed also w.r.t. the derived operators, i.e., *cross*, *repetition*, *optionality*, etc...
* *intersection*, *complement* (and *difference*) and *mirroring*
* <u>AN EVEN STRONGER PROPERTY</u>: the family REG of the regular languages is the <u>smallest family</u> of languages such that **both** the following properties hold
  * REG contains all finite languages
  * REG is closed w.r.t. concatenation, union and star

## Linguistic Abstraction

Compiler design makes reference to the abstract language to process, rather than to the effective language. Artificial languages (e.g., programming languages) contain few abstract structures, among which lists play a relevant role. 

**Lists** can be easily modeled by regexps
$$
ie(se)^*f  \qquad or \qquad   i[e(se)^*]f \ \ (can \ be\ empty)
$$

> * $i$ initial separator (e.g. begin)
> * $f$ final separator (e.g end)
> * $e$ element (e.g. instruction)
> * $s$ element separator (e.g. ';')
>

**Substitution (or Replacement)**: operation that replaces the terminal characters of the source language with the phrases of the target language. 

Given $L \subseteq \Sigma^*$ and $x = x_1x_2...x_n$ , we can substitute the language $L_b \subseteq \Delta^*$ to the letter $b$ : this produces a language over the alphabet $(\Sigma - \{b\}) \cup \Delta$ defined as follows
$$
L_{sub} =\{ y \ | \ y = y_1y_2...y_n \and (x_i = b \Rightarrow y_i \in L_b) \and (a_i \ne b \Rightarrow y_i = x_i)\}
$$
**N.b.** <u>Substitution in REGs has a maximum depth</u>



-------------------

# Free Grammars

$L_1 = \{ x \ | \  x = b^ne^n, n \ge 1 \}$ is **NOT REGULAR** -> wee need something more powerful -> **CONTEXT-FREE LANGUAGES**.

## Generative Grammars

In order to define a language, one can use **RULES** that allow to generate, after a repeated application, <u>all and only</u> the phrases of the language. The set of these rules is called **Generative Grammar** or **Syntax**.

An example for $L = \{uu^R \ | u \in \{a, b\}^*\}$  (palindromes):

> $$
> frase \rightarrow \epsilon \\
> frase \rightarrow a \ frase \ a \\
> frase \rightarrow  b \ frase \ b
> $$
>

### BNF entities

A **Context Free ** grammar (or simply FREE grammar) is defined by means of four entities (*BNF - Backus Normal Form*):

* $V$ 		*non-terminal alphabet* 
* $\Sigma$             *terminal alphabet*
* $P$             *set of Rules*
  * *Rule*: an ordered pair $(X, a)$  where $X \in V$ is a non-terminal and $a \in \{ V \cup \Sigma \}^*$ is a string that can contain terminal and non-terminal elements.
  * $(X, a) \in P \iff X \rightarrow a$
* $S \in V$     *Axiom*, a particular non terminal

### Naming Conventions

| Name                 | Symbol                         | Description                                       |
| -------------------- | ------------------------------ | ------------------------------------------------- |
| TERMINAL             | $\rightarrow u | \epsilon$     | the right part contains terminals or empty string |
| EMPTY                | $\rightarrow \epsilon$         | the right part is the empty string                |
| INITIAL              | $ S \rightarrow$               | the left part is the axiom                        |
| COPY (or RENAMING)   | $ A \rightarrow B$             | simply a change of name                           |
|                      |                                |                                                   |
| RECURSIVE            | $A \rightarrow \alpha A\beta $ | the left part appears in the righ part            |
| LEFT RECURSIVE       | $A \rightarrow A \beta $       | the left part is prefix of the right part         |
| RIGHT RECURSIVE      | $A \rightarrow \beta A$        | the left part is suffix of the right part         |
| TWO-SIDED RECURSIVE: | $A \rightarrow A \beta A $     | superposition of previous cases                   |
|                      |                                |                                                   |
| LINEAR               | $\rightarrow uBv \ | \ w $     | the right part contains at most one nonterminal   |
| RIGHT LINEAR         | $\rightarrow uB \ | w $        | like linear, but the nonterminal is suffix        |
| LEFT LINEAR          | $\rightarrow Bv \ | w $        | like linear, but the nonterminal is prefix        |
|                      |                                |                                                   |
| CHOMSKY NORMAL       | $\rightarrow BC | a$           | either one term. ot two nonterms                  |
| GREIBACH NORMAL      | $\rightarrow a\sigma | b$      | always a prefix term., max length 2               |
| OPERATOR NORMAL      | $\rightarrow AaB$              | always an infix terminal                          |

## Derivation and Generated Language

**Derivation:** We say that $\beta \Rightarrow_G \gamma $  ($\gamma$ *derives from* $\beta$ in the grammar $G$) if there is a rule in G that can transform $\beta$ into $\gamma$ (that can be both terminal or nonterminal).
$$
(\beta \Rightarrow_G \gamma)  \iff (A\rightarrow a) \in G \ \and \ \beta = bAd \rightarrow \gamma = bad 
$$

* A *form* generated by G, starting from the nonterminal A, is a string $ \alpha \in (V \cup \Sigma)^*$ such that $A \Rightarrow_G^* \alpha $
* If A is the axiom, the form is said to be *sentential*
* A *phrase* is a sentential form (derives from the axiom) that contains only terminal characters ($\alpha \in \Sigma^*$)

**Generated Language:** The language generated by G when starting from a nonterminal A, $L_A(G)$, is the set of strings that are derived from A:
$$
L_A(G)= \{ x \in \Sigma^* \ | \ A \Rightarrow^+ x \}
$$

If A is the axiom one can simply right $L(G) = L_S(G)$.

**Context-Free Languages:** a languages is said to be *context-free* ($\in LIB$) if and only if there is a free grammar that generates it.

**Equivalence:** Two grammars are equivalent $\iff$ they generate the same language, i.e. $L(G) = L(G')$

### Reduction

**Reduced Form:** a grammar is in a reduced form (or is *reduced*) if both

1. $ \exists\  S \Rightarrow^* \alpha A\beta$ , i.e. every nonterminal is reachable from the axiom
2. $\forall A \in V \qquad L_A(G) \ne \varnothing$, i.e. every nonterminal generates at least one string

**Reduction of a Grammar:** there is an alogrithm in two phases to find the reduced form of a grammar (correct and no useless rules)

1. Identify the non-terminal symbols that are **undefined** (don't generate strings)
   * Costruct the set $DEF = V - UNDEF$
   * Initially $DEF$ contains all the non-terminal that expand into terminals:
     * $DEF := \{ A \ | \ (A\rightarrow u) \in P, \ with \ u \in \Sigma^* \}$
   * Then all the nonterminals that expand into some of the elements in $DEF$ are added: this transformation is done repeatedly until it converges:
     * $DEF := DEF \cup \ \{ B \ | \ (B \rightarrow D_1D_2...D_n) \in P\}$ where $D_1 ... D_n $ are terminals or belong to $DEF$.
   * When no more elements can be added to $DEF$, this phase terminates: all the $UNDEF$ nonterminals can be eliminated, along with the rules in which they appear.
2. Indentify non-terminal symbols that are **unreachable** (from the axiom)
   * Can be reduced to the problem of the existence of a path in the graph associated with the relation $A\ produce \ B$ (i.e. $A \rightarrow \alpha B \beta$ with $A \ne B$ and $\alpha, \beta$ strings)
   * If a nonterminal cannot be reached from the axiom in this graph, it can be eliminated along with all the rules containing it
3. A third property that is often required for a grammar to be reduced is that there are no **circular derivations** (i.e. a derivation such that $A \Rightarrow^+ A$).
   * **N.B.** circular derivations can raise from a null rule such as $X \rightarrow XY, \quad Y \rightarrow \epsilon$ 

**N.b.** Even if properly reduced, a grammar may still exhibit *redundancy*

### Infinity of a Language

A necessary and sufficient condition for a language L(G) to be infinite, where G is reduced and has no circular derivations, is that G  admits *recursive derivations*:

* $S \Rightarrow^n xAy \quad n \ge 1$, immediately recursive if n = 1
* Proof Of Necessity
* Proof Of Sufficiency

A grammar is *recursion-free* $\iff$ the graph of the *produce* relation is acyclic

> *Example:*  finite language
> $$
> S \rightarrow aBc 
> \\
> B \rightarrow ab \ | \ Ca
> \\
> C \rightarrow c
> $$
> 










